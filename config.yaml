# SQL Proxy Configuration
# Environment variables can be used with ${VAR_NAME} syntax

server:
  host: "127.0.0.1"        # Listen address (use 0.0.0.0 for all interfaces)
  port: 8081               # HTTP port
  default_timeout_sec: 30  # Default query timeout (seconds)
  max_timeout_sec: 300     # Maximum allowed timeout (caps _timeout param)

database:
  host: "${DB_HOST}"           # SQL Server host (can use env var)
  port: 1433                   # SQL Server port
  user: "${DB_USER}"           # Database user
  password: "${DB_PASSWORD}"   # Database password
  database: "${DB_NAME}"       # Database name

# Logging Configuration
# JSON logs via slog, rotation via lumberjack
# Note: In interactive mode, logs go to stdout (file_path ignored)
#       In service mode, logs go to file only
logging:
  level: "info"                              # debug, info, warn, error
  file_path: "C:/Services/SQLProxy/logs/sql-proxy.log"  # Log file (service mode)
  max_size_mb: 100                           # Rotate at this size (default 100)
  max_backups: 5                             # Old files to keep (default 5)
  max_age_days: 30                           # Delete after days (default 30)

# Metrics Configuration
# Exposes metrics at /metrics endpoint
metrics:
  enabled: true

# Query Definitions
# Each query becomes an HTTP endpoint
# Parameters use @paramName syntax in SQL and are bound from query string
queries:
  # Example: Get all machines
  - name: "list_machines"
    path: "/api/machines"
    method: "GET"
    description: "List all biometric machines"
    sql: |
      SELECT
        MachineId,
        MachineName,
        MachineIP,
        LastPingTime,
        IsOnline
      FROM Machines
      ORDER BY MachineName

  # Example: Get machine by ID
  - name: "get_machine"
    path: "/api/machines/details"
    method: "GET"
    description: "Get machine details by ID"
    sql: |
      SELECT
        MachineId,
        MachineName,
        MachineIP,
        LastPingTime,
        IsOnline,
        Location,
        SerialNumber
      FROM Machines
      WHERE MachineId = @machineId
    parameters:
      - name: "machineId"
        type: "int"
        required: true

  # Example: Get machine ping history
  - name: "machine_ping_history"
    path: "/api/machines/ping-history"
    method: "GET"
    description: "Get ping history for a machine"
    sql: |
      SELECT TOP (@limit)
        PingTime,
        Status,
        ResponseTime
      FROM MachinePingLog
      WHERE MachineId = @machineId
        AND PingTime >= @fromDate
      ORDER BY PingTime DESC
    parameters:
      - name: "machineId"
        type: "int"
        required: true
      - name: "fromDate"
        type: "datetime"
        required: false
        default: "2024-01-01"
      - name: "limit"
        type: "int"
        required: false
        default: "100"

  # Example: Get check-in/out logs
  # This query has a custom timeout since it may scan large date ranges
  - name: "checkin_logs"
    path: "/api/checkins"
    method: "GET"
    description: "Get check-in/out logs for a date range"
    timeout_sec: 60  # Query-specific default (overrides server default)
    sql: |
      SELECT TOP (@limit)
        l.LogId,
        l.EmployeeId,
        l.MachineId,
        l.PunchTime,
        l.PunchType,
        m.MachineName
      FROM AttendanceLog l
      INNER JOIN Machines m ON l.MachineId = m.MachineId
      WHERE l.PunchTime BETWEEN @fromDate AND @toDate
      ORDER BY l.PunchTime DESC
    parameters:
      - name: "fromDate"
        type: "datetime"
        required: true
      - name: "toDate"
        type: "datetime"
        required: true
      - name: "limit"
        type: "int"
        required: false
        default: "1000"

  # Example: Get check-ins for specific employee
  - name: "employee_checkins"
    path: "/api/checkins/employee"
    method: "GET"
    description: "Get check-in/out logs for a specific employee"
    sql: |
      SELECT
        l.LogId,
        l.PunchTime,
        l.PunchType,
        m.MachineName,
        m.Location
      FROM AttendanceLog l
      INNER JOIN Machines m ON l.MachineId = m.MachineId
      WHERE l.EmployeeId = @employeeId
        AND l.PunchTime BETWEEN @fromDate AND @toDate
      ORDER BY l.PunchTime DESC
    parameters:
      - name: "employeeId"
        type: "string"
        required: true
      - name: "fromDate"
        type: "datetime"
        required: true
      - name: "toDate"
        type: "datetime"
        required: true

  # Example: Machine status summary (HTTP + scheduled)
  # This query is both an HTTP endpoint AND runs on a schedule
  - name: "machine_status_summary"
    path: "/api/machines/status-summary"
    method: "GET"
    description: "Get summary of machine online/offline status"
    sql: |
      SELECT
        COUNT(*) AS TotalMachines,
        SUM(CASE WHEN IsOnline = 1 THEN 1 ELSE 0 END) AS OnlineMachines,
        SUM(CASE WHEN IsOnline = 0 THEN 1 ELSE 0 END) AS OfflineMachines,
        MIN(LastPingTime) AS OldestPing,
        MAX(LastPingTime) AS LatestPing
      FROM Machines
    schedule:
      cron: "*/5 * * * *"    # Run every 5 minutes
      log_results: true      # Log the actual row data

  # Example: Scheduled-only query (no HTTP endpoint)
  # This query runs daily and logs yesterday's attendance count
  # - name: "daily_attendance_count"
  #   description: "Count yesterday's attendance records"
  #   sql: |
  #     SELECT
  #       COUNT(*) AS TotalCheckins,
  #       COUNT(DISTINCT EmployeeId) AS UniqueEmployees,
  #       CAST(@reportDate AS DATE) AS ReportDate
  #     FROM AttendanceLog
  #     WHERE CAST(PunchTime AS DATE) = CAST(@reportDate AS DATE)
  #   parameters:
  #     - name: "reportDate"
  #       type: "datetime"
  #       required: true
  #   schedule:
  #     cron: "0 8 * * *"      # Run at 8 AM daily
  #     params:
  #       reportDate: "yesterday"  # Dynamic date: resolves to yesterday at runtime
  #     log_results: true
