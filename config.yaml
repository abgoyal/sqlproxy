# SQL Proxy Configuration
# Environment variables can be used with ${VAR_NAME} syntax
# All fields are required - no defaults are assumed

server:
  host: "127.0.0.1"        # Listen address (use 0.0.0.0 for all interfaces)
  port: 8081               # HTTP port
  default_timeout_sec: 30  # Default query timeout (seconds)
  max_timeout_sec: 300     # Maximum allowed timeout (caps _timeout param)

# Database connections - type-specific fields required
databases:
  - name: "primary"                # Connection name (referenced by queries)
    type: "sqlserver"              # Database type: sqlserver, sqlite (default: sqlserver)
    host: "${DB_HOST}"             # SQL Server host
    port: 1433                     # SQL Server port (typically 1433)
    user: "${DB_USER}"             # Database user
    password: "${DB_PASSWORD}"     # Database password
    database: "${DB_NAME}"         # Database name
    readonly: true                 # Connection routing: ApplicationIntent=ReadOnly
    # Session defaults (optional - these are the implicit defaults for readonly: true)
    # isolation: "read_uncommitted"   # read_uncommitted, read_committed, repeatable_read, serializable, snapshot
    # lock_timeout_ms: 5000           # Lock wait timeout in milliseconds
    # deadlock_priority: "low"        # low, normal, high

  # Example: SQLite database (useful for testing)
  # - name: "test_db"
  #   type: "sqlite"
  #   path: ":memory:"              # File path or :memory: for in-memory database
  #   # SQLite session settings (optional)
  #   # journal_mode: "wal"         # wal, delete, truncate, memory, off (default: wal)
  #   # busy_timeout_ms: 5000       # Busy timeout in milliseconds (default: 5000)

# Logging Configuration - all fields required
logging:
  level: "info"                              # debug, info, warn, error
  file_path: "C:/Services/SQLProxy/logs/sql-proxy.log"  # Log file (service mode)
  max_size_mb: 100                           # Rotate at this size
  max_backups: 5                             # Old files to keep
  max_age_days: 30                           # Delete after days

# Metrics Configuration
metrics:
  enabled: true

# Query Definitions - each query requires: name, database, sql
# HTTP endpoints also require: path, method
queries:
  # Example: Get all machines
  - name: "list_machines"
    database: "primary"
    path: "/api/machines"
    method: "GET"
    description: "List all biometric machines"
    sql: |
      SELECT
        MachineId,
        MachineName,
        MachineIP,
        LastPingTime,
        IsOnline
      FROM Machines
      ORDER BY MachineName

  # Example: Get machine by ID
  - name: "get_machine"
    database: "primary"
    path: "/api/machines/details"
    method: "GET"
    description: "Get machine details by ID"
    sql: |
      SELECT
        MachineId,
        MachineName,
        MachineIP,
        LastPingTime,
        IsOnline,
        Location,
        SerialNumber
      FROM Machines
      WHERE MachineId = @machineId
    parameters:
      - name: "machineId"
        type: "int"
        required: true

  # Example: Get machine ping history
  - name: "machine_ping_history"
    database: "primary"
    path: "/api/machines/ping-history"
    method: "GET"
    description: "Get ping history for a machine"
    sql: |
      SELECT TOP (@limit)
        PingTime,
        Status,
        ResponseTime
      FROM MachinePingLog
      WHERE MachineId = @machineId
        AND PingTime >= @fromDate
      ORDER BY PingTime DESC
    parameters:
      - name: "machineId"
        type: "int"
        required: true
      - name: "fromDate"
        type: "datetime"
        required: false
        default: "2024-01-01"
      - name: "limit"
        type: "int"
        required: false
        default: "100"

  # Example: Get check-in/out logs
  # This query has a custom timeout since it may scan large date ranges
  - name: "checkin_logs"
    database: "primary"
    path: "/api/checkins"
    method: "GET"
    description: "Get check-in/out logs for a date range"
    timeout_sec: 60  # Query-specific timeout (overrides server default)
    sql: |
      SELECT TOP (@limit)
        l.LogId,
        l.EmployeeId,
        l.MachineId,
        l.PunchTime,
        l.PunchType,
        m.MachineName
      FROM AttendanceLog l
      INNER JOIN Machines m ON l.MachineId = m.MachineId
      WHERE l.PunchTime BETWEEN @fromDate AND @toDate
      ORDER BY l.PunchTime DESC
    parameters:
      - name: "fromDate"
        type: "datetime"
        required: true
      - name: "toDate"
        type: "datetime"
        required: true
      - name: "limit"
        type: "int"
        required: false
        default: "1000"

  # Example: Get check-ins for specific employee
  # This query overrides isolation to READ COMMITTED for consistent reads
  - name: "employee_checkins"
    database: "primary"
    path: "/api/checkins/employee"
    method: "GET"
    description: "Get check-in/out logs for a specific employee"
    isolation: "read_committed"    # Override: need consistent reads (no dirty reads)
    sql: |
      SELECT
        l.LogId,
        l.PunchTime,
        l.PunchType,
        m.MachineName,
        m.Location
      FROM AttendanceLog l
      INNER JOIN Machines m ON l.MachineId = m.MachineId
      WHERE l.EmployeeId = @employeeId
        AND l.PunchTime BETWEEN @fromDate AND @toDate
      ORDER BY l.PunchTime DESC
    parameters:
      - name: "employeeId"
        type: "string"
        required: true
      - name: "fromDate"
        type: "datetime"
        required: true
      - name: "toDate"
        type: "datetime"
        required: true

  # Example: Machine status summary (HTTP + scheduled)
  # This query is both an HTTP endpoint AND runs on a schedule
  - name: "machine_status_summary"
    database: "primary"
    path: "/api/machines/status-summary"
    method: "GET"
    description: "Get summary of machine online/offline status"
    sql: |
      SELECT
        COUNT(*) AS TotalMachines,
        SUM(CASE WHEN IsOnline = 1 THEN 1 ELSE 0 END) AS OnlineMachines,
        SUM(CASE WHEN IsOnline = 0 THEN 1 ELSE 0 END) AS OfflineMachines,
        MIN(LastPingTime) AS OldestPing,
        MAX(LastPingTime) AS LatestPing
      FROM Machines
    schedule:
      cron: "*/5 * * * *"    # Run every 5 minutes
      log_results: true      # Log the actual row data

  # Example: Scheduled-only query (no HTTP endpoint)
  # This query runs daily and logs yesterday's attendance count
  # - name: "daily_attendance_count"
  #   database: "primary"
  #   description: "Count yesterday's attendance records"
  #   sql: |
  #     SELECT
  #       COUNT(*) AS TotalCheckins,
  #       COUNT(DISTINCT EmployeeId) AS UniqueEmployees,
  #       CAST(@reportDate AS DATE) AS ReportDate
  #     FROM AttendanceLog
  #     WHERE CAST(PunchTime AS DATE) = CAST(@reportDate AS DATE)
  #   parameters:
  #     - name: "reportDate"
  #       type: "datetime"
  #       required: true
  #   schedule:
  #     cron: "0 8 * * *"      # Run at 8 AM daily
  #     params:
  #       reportDate: "yesterday"  # Dynamic date: resolves to yesterday at runtime
  #     log_results: true
