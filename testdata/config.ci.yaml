# Extensive CI validation config
# Exercises all features using SQLite in-memory (no external dependencies)
# This config is used by CI to validate that the config parser works correctly

server:
  host: "127.0.0.1"
  port: 8080
  default_timeout_sec: 30
  max_timeout_sec: 300
  api_version: "1.0.0"
  trust_proxy_headers: true
  cache:
    enabled: true
    max_size_mb: 256
    default_ttl_sec: 300

# Multiple databases with various configurations
databases:
  # Primary database with all SQLite options
  - name: "primary"
    type: "sqlite"
    path: ":memory:"
    readonly: true
    journal_mode: "wal"
    busy_timeout_ms: 5000
    max_open_conns: 10
    max_idle_conns: 5
    conn_max_lifetime: 300
    conn_max_idle_time: 120

  # Secondary database with different settings
  - name: "secondary"
    type: "sqlite"
    path: ":memory:"
    readonly: true
    journal_mode: "memory"
    busy_timeout_ms: 3000
    max_open_conns: 5
    max_idle_conns: 2

  # Write-enabled database for POST operations
  - name: "writable"
    type: "sqlite"
    path: ":memory:"
    readonly: false
    journal_mode: "delete"

  # Minimal config database (defaults only)
  - name: "minimal"
    type: "sqlite"
    path: ":memory:"

logging:
  level: "info"
  file_path: "./logs/test.log"
  max_size_mb: 100
  max_backups: 5
  max_age_days: 30

metrics:
  enabled: true

debug:
  enabled: true
  port: 6060
  host: "localhost"

# Named rate limit pools
rate_limits:
  - name: "default"
    requests_per_second: 100
    burst: 200
    key: "{{.ClientIP}}"

  - name: "strict"
    requests_per_second: 10
    burst: 20
    key: "{{.ClientIP}}"

  - name: "by_param"
    requests_per_second: 50
    burst: 100
    key: "{{.ClientIP}}:{{.user_id}}"

# Workflows - comprehensive test coverage
workflows:
  # Basic HTTP workflow with single query step
  - name: "basic_http_workflow"
    triggers:
      - type: http
        path: "/api/v2/basic"
        method: GET
    steps:
      - name: fetch
        type: query
        database: "primary"
        sql: "SELECT 'basic workflow' AS result"
      - type: response
        template: |
          {"success": true, "data": {{json .steps.fetch.data}}}

  # HTTP workflow with parameters
  - name: "workflow_with_params"
    triggers:
      - type: http
        path: "/api/v2/echo"
        method: GET
        parameters:
          - name: "message"
            type: "string"
            required: false
            default: "hello"
          - name: "count"
            type: "int"
            required: false
            default: "1"
    steps:
      - name: echo
        type: query
        database: "primary"
        sql: "SELECT @message AS message, @count AS count"
      - type: response
        template: |
          {"message": "{{index .steps.echo.data 0 \"message\"}}", "count": {{index .steps.echo.data 0 "count"}}}

  # HTTP workflow with conditional responses
  - name: "workflow_conditional"
    conditions:
      has_data: "steps.fetch.count > 0"
      no_data: "steps.fetch.count == 0"
    triggers:
      - type: http
        path: "/api/v2/conditional"
        method: GET
        parameters:
          - name: "find_data"
            type: "bool"
            required: false
            default: "true"
    steps:
      - name: fetch
        type: query
        database: "primary"
        sql: "SELECT CASE WHEN @find_data THEN 'found' ELSE NULL END AS result WHERE @find_data"
      - type: response
        condition: "has_data"
        template: |
          {"success": true, "data": {{json .steps.fetch.data}}}
      - type: response
        condition: "no_data"
        status_code: 404
        template: |
          {"success": false, "error": "No data found"}

  # HTTP workflow with cache
  - name: "workflow_cached"
    triggers:
      - type: http
        path: "/api/v2/cached"
        method: GET
        cache:
          enabled: true
          key: "workflow:cached"
          ttl_sec: 60
        parameters:
          - name: "status"
            type: "string"
            required: false
            default: "active"
    steps:
      - name: fetch
        type: query
        database: "primary"
        sql: "SELECT @status AS status, datetime('now') AS timestamp"
      - type: response
        template: |
          {"status": "{{index .steps.fetch.data 0 \"status\"}}", "cached_at": "{{index .steps.fetch.data 0 \"timestamp\"}}"}

  # HTTP workflow with rate limiting
  - name: "workflow_rate_limited"
    triggers:
      - type: http
        path: "/api/v2/limited"
        method: GET
        rate_limit:
          - pool: "default"
    steps:
      - name: fetch
        type: query
        database: "primary"
        sql: "SELECT 'rate limited' AS result"
      - type: response
        template: |
          {"result": "{{index .steps.fetch.data 0 \"result\"}}"}

  # HTTP workflow with inline rate limiting
  - name: "workflow_rate_limited_inline"
    triggers:
      - type: http
        path: "/api/v2/limited/inline"
        method: GET
        rate_limit:
          - requests_per_second: 10
            burst: 20
            key: "{{.ClientIP}}"
    steps:
      - name: fetch
        type: query
        database: "primary"
        sql: "SELECT 'inline limited' AS result"
      - type: response
        template: |
          {"result": "{{index .steps.fetch.data 0 \"result\"}}"}

  # POST workflow
  - name: "workflow_post"
    triggers:
      - type: http
        path: "/api/v2/submit"
        method: POST
        parameters:
          - name: "data"
            type: "json"
            required: true
    steps:
      - name: process
        type: query
        database: "writable"
        sql: "SELECT @data AS submitted"
      - type: response
        template: |
          {"success": true, "received": {{json .steps.process.data}}}

  # PUT workflow
  - name: "workflow_put"
    triggers:
      - type: http
        path: "/api/v2/items"
        method: PUT
        parameters:
          - name: "id"
            type: "int"
            required: true
          - name: "name"
            type: "string"
            required: true
    steps:
      - name: update
        type: query
        database: "writable"
        sql: "SELECT @id AS id, @name AS updated_name"
      - type: response
        template: |
          {"success": true, "updated": {{json (index .steps.update.data 0)}}}

  # DELETE workflow
  - name: "workflow_delete"
    triggers:
      - type: http
        path: "/api/v2/items"
        method: DELETE
        parameters:
          - name: "id"
            type: "int"
            required: true
    steps:
      - name: delete
        type: query
        database: "writable"
        sql: "SELECT @id AS deleted_id"
      - type: response
        template: |
          {"success": true, "deleted_id": {{index .steps.delete.data 0 "deleted_id"}}}

  # PATCH workflow
  - name: "workflow_patch"
    triggers:
      - type: http
        path: "/api/v2/items"
        method: PATCH
        parameters:
          - name: "id"
            type: "int"
            required: true
          - name: "field"
            type: "string"
            required: true
          - name: "value"
            type: "string"
            required: true
    steps:
      - name: patch
        type: query
        database: "writable"
        sql: "SELECT @id AS id, @field AS field, @value AS value"
      - type: response
        template: |
          {"success": true, "patched": {{json (index .steps.patch.data 0)}}}

  # HEAD workflow (no body response, uses headers only)
  - name: "workflow_head"
    triggers:
      - type: http
        path: "/api/v2/items/exists"
        method: HEAD
        parameters:
          - name: "id"
            type: "int"
            required: true
    steps:
      - name: check
        type: query
        database: "primary"
        sql: "SELECT 1 AS exists WHERE @id > 0"
      - type: response
        headers:
          X-Exists: "{{if gt .steps.check.count 0}}true{{else}}false{{end}}"
        template: "{}"

  # OPTIONS workflow
  - name: "workflow_options"
    triggers:
      - type: http
        path: "/api/v2/items"
        method: OPTIONS
    steps:
      - type: response
        headers:
          Allow: "GET, POST, PUT, DELETE, PATCH, HEAD, OPTIONS"
        template: |
          {"methods": ["GET", "POST", "PUT", "DELETE", "PATCH", "HEAD", "OPTIONS"]}

  # Same path, different method (RESTful pattern) - GET for /api/v2/items
  - name: "workflow_get_items"
    triggers:
      - type: http
        path: "/api/v2/items"
        method: GET
    steps:
      - name: fetch
        type: query
        database: "primary"
        sql: "SELECT 1 AS id, 'item1' AS name UNION ALL SELECT 2, 'item2'"
      - type: response
        template: |
          {"items": {{json .steps.fetch.data}}}

  # Cron-triggered workflow
  - name: "workflow_scheduled"
    triggers:
      - type: cron
        schedule: "*/5 * * * *"
    steps:
      - name: run
        type: query
        database: "primary"
        sql: "SELECT datetime('now') AS run_time, 'scheduled workflow' AS type"

  # Cron workflow with parameters
  - name: "workflow_scheduled_params"
    triggers:
      - type: cron
        schedule: "0 8 * * *"
        params:
          report_date: "yesterday"
    steps:
      - name: report
        type: query
        database: "primary"
        sql: "SELECT @report_date AS report_date"

  # Workflow with multiple triggers (HTTP + cron)
  - name: "workflow_dual_trigger"
    triggers:
      - type: http
        path: "/api/v2/dual"
        method: GET
      - type: cron
        schedule: "0 * * * *"
    steps:
      - name: fetch
        type: query
        database: "primary"
        sql: "SELECT datetime('now') AS timestamp, 'dual trigger' AS mode"
      - type: response
        template: |
          {"timestamp": "{{index .steps.fetch.data 0 \"timestamp\"}}", "mode": "{{index .steps.fetch.data 0 \"mode\"}}"}

  # Workflow with multiple query steps
  - name: "workflow_multi_query"
    triggers:
      - type: http
        path: "/api/v2/multi"
        method: GET
    steps:
      - name: query1
        type: query
        database: "primary"
        sql: "SELECT 'first' AS step"
      - name: query2
        type: query
        database: "secondary"
        sql: "SELECT 'second' AS step"
      - type: response
        template: |
          {"step1": {{json .steps.query1.data}}, "step2": {{json .steps.query2.data}}}

  # Workflow with httpcall step
  - name: "workflow_httpcall"
    triggers:
      - type: http
        path: "/api/v2/proxy"
        method: GET
        parameters:
          - name: "endpoint"
            type: "string"
            required: false
            default: "https://example.com/api"
    steps:
      - name: external
        type: httpcall
        url: "{{.trigger.params.endpoint}}"
        http_method: GET
        headers:
          Accept: "application/json"
        parse: "json"
      - type: response
        template: |
          {"external_status": {{.steps.external.status_code}}, "data": {{json .steps.external.data}}}

  # Workflow with httpcall and retry
  - name: "workflow_httpcall_retry"
    triggers:
      - type: http
        path: "/api/v2/proxy/retry"
        method: POST
        parameters:
          - name: "data"
            type: "json"
            required: true
    steps:
      - name: post_external
        type: httpcall
        url: "https://example.com/api/submit"
        http_method: POST
        headers:
          Content-Type: "application/json"
        body: "{{json .trigger.params.data}}"
        parse: "json"
        timeout_sec: 30
        retry:
          enabled: true
          max_attempts: 3
          initial_backoff_sec: 1
          max_backoff_sec: 10
      - type: response
        template: |
          {"success": true, "external_response": {{json .steps.post_external.data}}}

  # Workflow with block (iteration)
  - name: "workflow_block"
    triggers:
      - type: http
        path: "/api/v2/batch"
        method: GET
    steps:
      - name: fetch_items
        type: query
        database: "primary"
        sql: "SELECT 1 AS id, 'item1' AS name UNION ALL SELECT 2, 'item2' UNION ALL SELECT 3, 'item3'"
      - name: process_items
        iterate:
          over: "steps.fetch_items.data"
          as: "item"
          on_error: continue
        steps:
          - name: process
            type: query
            database: "primary"
            sql: "SELECT 'processed' AS status, @item_id AS item_id"
            params:
              item_id: "{{.item.id}}"
      - type: response
        template: |
          {"total": {{.steps.fetch_items.count}}, "processed": {{.steps.process_items.success_count}}}

  # Workflow with disabled step
  - name: "workflow_disabled_step"
    triggers:
      - type: http
        path: "/api/v2/disabled"
        method: GET
    steps:
      - name: active
        type: query
        database: "primary"
        sql: "SELECT 'active' AS result"
      - name: disabled
        type: query
        database: "primary"
        sql: "SELECT 'this should not run' AS result"
        disabled: true
      - type: response
        template: |
          {"result": "{{index .steps.active.data 0 \"result\"}}"}

  # Workflow with on_error: continue
  - name: "workflow_error_continue"
    triggers:
      - type: http
        path: "/api/v2/resilient"
        method: GET
    steps:
      - name: may_fail
        type: query
        database: "primary"
        sql: "SELECT 'ok' AS result"
        on_error: continue
      - name: always_runs
        type: query
        database: "primary"
        sql: "SELECT 'always' AS result"
      - type: response
        template: |
          {"result": "{{index .steps.always_runs.data 0 \"result\"}}"}

  # Workflow with timeout
  - name: "workflow_timeout"
    timeout_sec: 30
    triggers:
      - type: http
        path: "/api/v2/timeout"
        method: GET
    steps:
      - name: fetch
        type: query
        database: "primary"
        sql: "SELECT 'quick' AS result"
      - type: response
        template: |
          {"result": "{{index .steps.fetch.data 0 \"result\"}}"}

  # Workflow with JSON columns
  - name: "workflow_json_columns"
    triggers:
      - type: http
        path: "/api/v2/json"
        method: GET
    steps:
      - name: fetch
        type: query
        database: "primary"
        sql: "SELECT '{\"key\": \"value\"}' AS data"
        json_columns: ["data"]
      - type: response
        template: |
          {"parsed": {{json .steps.fetch.data}}}

  # Workflow with session overrides
  - name: "workflow_session"
    triggers:
      - type: http
        path: "/api/v2/session"
        method: GET
    steps:
      - name: fetch
        type: query
        database: "primary"
        sql: "SELECT 'session test' AS result"
        isolation: "read_committed"
      - type: response
        template: |
          {"result": "{{index .steps.fetch.data 0 \"result\"}}"}

  # ============================================
  # Parameter Type Tests (equivalent to queries)
  # ============================================

  # Integer alias parameter
  - name: "workflow_param_integer"
    triggers:
      - type: http
        path: "/api/v2/params/integer"
        method: GET
        parameters:
          - name: "num"
            type: "integer"
            required: true
    steps:
      - name: echo
        type: query
        database: "primary"
        sql: "SELECT @num AS number"
      - type: response
        template: |
          {"number": {{index .steps.echo.data 0 "number"}}}

  # Float parameter
  - name: "workflow_param_float"
    triggers:
      - type: http
        path: "/api/v2/params/float"
        method: GET
        parameters:
          - name: "amount"
            type: "float"
            required: true
    steps:
      - name: echo
        type: query
        database: "primary"
        sql: "SELECT @amount AS amount, round(@amount, 2) AS rounded"
      - type: response
        template: |
          {"amount": {{index .steps.echo.data 0 "amount"}}, "rounded": {{index .steps.echo.data 0 "rounded"}}}

  # Double alias parameter
  - name: "workflow_param_double"
    triggers:
      - type: http
        path: "/api/v2/params/double"
        method: GET
        parameters:
          - name: "value"
            type: "double"
            required: true
    steps:
      - name: echo
        type: query
        database: "primary"
        sql: "SELECT @value AS value"
      - type: response
        template: |
          {"value": {{index .steps.echo.data 0 "value"}}}

  # Boolean alias parameter
  - name: "workflow_param_boolean"
    triggers:
      - type: http
        path: "/api/v2/params/boolean"
        method: GET
        parameters:
          - name: "active"
            type: "boolean"
            required: true
    steps:
      - name: echo
        type: query
        database: "primary"
        sql: "SELECT @active AS active"
      - type: response
        template: |
          {"active": {{index .steps.echo.data 0 "active"}}}

  # Datetime parameter
  - name: "workflow_param_datetime"
    triggers:
      - type: http
        path: "/api/v2/params/datetime"
        method: GET
        parameters:
          - name: "timestamp"
            type: "datetime"
            required: false
            default: "2024-01-01T00:00:00Z"
    steps:
      - name: echo
        type: query
        database: "primary"
        sql: "SELECT @timestamp AS timestamp, datetime(@timestamp) AS parsed"
      - type: response
        template: |
          {"timestamp": "{{index .steps.echo.data 0 \"timestamp\"}}"}

  # Date parameter
  - name: "workflow_param_date"
    triggers:
      - type: http
        path: "/api/v2/params/date"
        method: GET
        parameters:
          - name: "day"
            type: "date"
            required: true
    steps:
      - name: echo
        type: query
        database: "primary"
        sql: "SELECT @day AS day, date(@day) AS parsed"
      - type: response
        template: |
          {"day": "{{index .steps.echo.data 0 \"day\"}}"}

  # Integer array parameter
  - name: "workflow_param_int_array"
    triggers:
      - type: http
        path: "/api/v2/params/int-array"
        method: POST
        parameters:
          - name: "ids"
            type: "int[]"
            required: true
    steps:
      - name: echo
        type: query
        database: "primary"
        sql: "SELECT @ids AS ids"
      - type: response
        template: |
          {"ids": "{{index .steps.echo.data 0 \"ids\"}}"}

  # String array parameter
  - name: "workflow_param_string_array"
    triggers:
      - type: http
        path: "/api/v2/params/string-array"
        method: POST
        parameters:
          - name: "names"
            type: "string[]"
            required: true
    steps:
      - name: echo
        type: query
        database: "primary"
        sql: "SELECT @names AS names"
      - type: response
        template: |
          {"names": "{{index .steps.echo.data 0 \"names\"}}"}

  # Float array parameter
  - name: "workflow_param_float_array"
    triggers:
      - type: http
        path: "/api/v2/params/float-array"
        method: POST
        parameters:
          - name: "values"
            type: "float[]"
            required: true
    steps:
      - name: echo
        type: query
        database: "primary"
        sql: "SELECT @values AS values"
      - type: response
        template: |
          {"values": "{{index .steps.echo.data 0 \"values\"}}"}

  # Bool array parameter
  - name: "workflow_param_bool_array"
    triggers:
      - type: http
        path: "/api/v2/params/bool-array"
        method: POST
        parameters:
          - name: "flags"
            type: "bool[]"
            required: true
    steps:
      - name: echo
        type: query
        database: "primary"
        sql: "SELECT @flags AS flags"
      - type: response
        template: |
          {"flags": "{{index .steps.echo.data 0 \"flags\"}}"}

  # Multiple parameter types combined
  - name: "workflow_param_multi"
    triggers:
      - type: http
        path: "/api/v2/params/multi"
        method: GET
        parameters:
          - name: "name"
            type: "string"
            required: true
          - name: "age"
            type: "int"
            required: false
            default: "0"
          - name: "score"
            type: "float"
            required: false
            default: "0.0"
          - name: "active"
            type: "bool"
            required: false
            default: "true"
          - name: "created"
            type: "datetime"
            required: false
            default: "2024-01-01"
    steps:
      - name: echo
        type: query
        database: "primary"
        sql: |
          SELECT
            @name AS name,
            @age AS age,
            @score AS score,
            @active AS active,
            @created AS created
      - type: response
        template: |
          {"name": "{{index .steps.echo.data 0 \"name\"}}", "age": {{index .steps.echo.data 0 "age"}}}

  # ============================================
  # Step-Level Cache Tests (NEW: caching individual step results)
  # ============================================

  # Basic step cache
  - name: "workflow_step_cache_basic"
    triggers:
      - type: http
        path: "/api/v2/step-cache/basic"
        method: GET
        parameters:
          - name: "id"
            type: "int"
            required: true
    steps:
      - name: fetch
        type: query
        database: "primary"
        sql: "SELECT @id AS id, datetime('now') AS fetched_at"
        cache:
          key: "step:item:{{.Param.id}}"
          ttl_sec: 300
      - type: response
        template: |
          {"data": {{json (index .steps.fetch.data 0)}}, "cache_hit": {{.steps.fetch.cache_hit}}}

  # Step cache with multiple cached steps
  - name: "workflow_step_cache_multi"
    triggers:
      - type: http
        path: "/api/v2/step-cache/multi"
        method: GET
        parameters:
          - name: "user_id"
            type: "int"
            required: true
    steps:
      # First cached step
      - name: user
        type: query
        database: "primary"
        sql: "SELECT @user_id AS id, 'User ' || @user_id AS name"
        cache:
          key: "step:user:{{.Param.user_id}}"
          ttl_sec: 300
      # Second cached step with different TTL
      - name: settings
        type: query
        database: "primary"
        sql: "SELECT 'default' AS theme, 10 AS page_size"
        cache:
          key: "step:settings:{{.Param.user_id}}"
          ttl_sec: 600
      - type: response
        template: |
          {
            "user": {{json (index .steps.user.data 0)}},
            "user_cached": {{.steps.user.cache_hit}},
            "settings": {{json (index .steps.settings.data 0)}},
            "settings_cached": {{.steps.settings.cache_hit}}
          }

  # Step cache referencing previous step result in key
  - name: "workflow_step_cache_chained"
    triggers:
      - type: http
        path: "/api/v2/step-cache/chained"
        method: GET
        parameters:
          - name: "user_id"
            type: "int"
            required: true
    steps:
      - name: user
        type: query
        database: "primary"
        sql: "SELECT @user_id AS id, 100 + @user_id AS org_id"
        cache:
          key: "step:user:{{.Param.user_id}}"
          ttl_sec: 300
      # Cache key uses result from previous step via params
      - name: org
        type: query
        database: "primary"
        sql: "SELECT @org_id AS org_id, 'Org' AS name"
        params:
          org_id: "{{index .steps.user.data 0 \"org_id\"}}"
        cache:
          key: "step:org:{{index .steps.user.data 0 \"org_id\"}}"
          ttl_sec: 600
      - type: response
        template: |
          {"user": {{json (index .steps.user.data 0)}}, "org": {{json (index .steps.org.data 0)}}}

  # Combined trigger-level and step-level caching
  - name: "workflow_dual_cache"
    triggers:
      - type: http
        path: "/api/v2/cache/dual"
        method: GET
        parameters:
          - name: "id"
            type: "int"
            required: true
        cache:
          enabled: true
          key: "trigger:product:{{.Param.id}}"
          ttl_sec: 60
    steps:
      - name: product
        type: query
        database: "primary"
        sql: "SELECT @id AS id, 'Product ' || @id AS name"
        cache:
          key: "step:product:{{.Param.id}}"
          ttl_sec: 600
      - name: price
        type: query
        database: "primary"
        sql: "SELECT @id AS product_id, 99.99 AS price"
        cache:
          key: "step:price:{{.Param.id}}"
          ttl_sec: 120
      - type: response
        template: |
          {"product": {{json (index .steps.product.data 0)}}, "price": {{index .steps.price.data 0 "price"}}}

  # Step cache with httpcall
  - name: "workflow_step_cache_httpcall"
    triggers:
      - type: http
        path: "/api/v2/step-cache/external"
        method: GET
        parameters:
          - name: "resource"
            type: "string"
            required: true
    steps:
      - name: fetch_external
        type: httpcall
        url: "https://example.com/api/{{.trigger.params.resource}}"
        http_method: GET
        parse: "json"
        cache:
          key: "step:external:{{.Param.resource}}"
          ttl_sec: 300
      - type: response
        template: |
          {"data": {{json .steps.fetch_external.data}}, "cache_hit": {{.steps.fetch_external.cache_hit}}}

  # ============================================
  # Trigger-Level Cache Tests (response caching)
  # ============================================

  # Cache with parameter key
  - name: "workflow_cached_param"
    triggers:
      - type: http
        path: "/api/v2/cached/param"
        method: GET
        parameters:
          - name: "status"
            type: "string"
            required: false
            default: "active"
        cache:
          enabled: true
          key: "wf:status:{{.status}}"
          ttl_sec: 120
          max_size_mb: 32
    steps:
      - name: fetch
        type: query
        database: "primary"
        sql: "SELECT @status AS status, datetime('now') AS timestamp"
      - type: response
        template: |
          {"status": "{{index .steps.fetch.data 0 \"status\"}}", "timestamp": "{{index .steps.fetch.data 0 \"timestamp\"}}"}

  # Cache with multi-param key
  - name: "workflow_cached_multi"
    triggers:
      - type: http
        path: "/api/v2/cached/multi"
        method: GET
        parameters:
          - name: "from"
            type: "date"
            required: true
          - name: "to"
            type: "date"
            required: true
        cache:
          enabled: true
          key: "wf:range:{{.from}}:{{.to}}"
          ttl_sec: 300
    steps:
      - name: fetch
        type: query
        database: "primary"
        sql: "SELECT @from AS from_date, @to AS to_date"
      - type: response
        template: |
          {"from": "{{index .steps.fetch.data 0 \"from_date\"}}", "to": "{{index .steps.fetch.data 0 \"to_date\"}}"}

  # Cache with evict_cron
  - name: "workflow_cached_evict"
    triggers:
      - type: http
        path: "/api/v2/cached/evict"
        method: GET
        cache:
          enabled: true
          key: "wf:evicting"
          ttl_sec: 3600
          evict_cron: "0 0 * * *"
    steps:
      - name: fetch
        type: query
        database: "primary"
        sql: "SELECT 'data' AS result"
      - type: response
        template: |
          {"result": "{{index .steps.fetch.data 0 \"result\"}}"}

  # Cache with default template function
  - name: "workflow_cached_default"
    triggers:
      - type: http
        path: "/api/v2/cached/default"
        method: GET
        parameters:
          - name: "category"
            type: "string"
            required: false
        cache:
          enabled: true
          key: "wf:items:{{.category | default \"all\"}}"
          ttl_sec: 300
    steps:
      - name: fetch
        type: query
        database: "primary"
        sql: "SELECT @category AS category"
      - type: response
        template: |
          {"category": "{{index .steps.fetch.data 0 \"category\"}}"}

  # ============================================
  # Rate Limiting Tests (equivalent to queries)
  # ============================================

  # Rate limit with param-based key (using pool)
  - name: "workflow_rate_limited_param"
    triggers:
      - type: http
        path: "/api/v2/limited/param"
        method: GET
        parameters:
          - name: "user_id"
            type: "string"
            required: true
        rate_limit:
          - pool: "by_param"
    steps:
      - name: fetch
        type: query
        database: "primary"
        sql: "SELECT @user_id AS user_id"
      - type: response
        template: |
          {"user_id": "{{index .steps.fetch.data 0 \"user_id\"}}"}

  # Multiple rate limits
  - name: "workflow_rate_limited_multi"
    triggers:
      - type: http
        path: "/api/v2/limited/multi"
        method: GET
        rate_limit:
          - pool: "default"
          - requests_per_second: 20
            burst: 40
    steps:
      - name: fetch
        type: query
        database: "primary"
        sql: "SELECT 'multi limited' AS result"
      - type: response
        template: |
          {"result": "{{index .steps.fetch.data 0 \"result\"}}"}

  # Strict rate limit pool
  - name: "workflow_rate_limited_strict"
    triggers:
      - type: http
        path: "/api/v2/limited/strict"
        method: GET
        rate_limit:
          - pool: "strict"
    steps:
      - name: fetch
        type: query
        database: "primary"
        sql: "SELECT 'strict' AS result"
      - type: response
        template: |
          {"result": "{{index .steps.fetch.data 0 \"result\"}}"}

  # ============================================
  # Scheduled Workflows with Dynamic Dates
  # ============================================

  # Cron with today param
  - name: "workflow_cron_today"
    triggers:
      - type: cron
        schedule: "0 0 * * *"
        params:
          date: "today"
    steps:
      - name: run
        type: query
        database: "primary"
        sql: "SELECT @date AS date_value"

  # Cron with yesterday param
  - name: "workflow_cron_yesterday"
    triggers:
      - type: cron
        schedule: "0 8 * * *"
        params:
          report_date: "yesterday"
    steps:
      - name: run
        type: query
        database: "primary"
        sql: "SELECT @report_date AS report_date"

  # Cron with now param
  - name: "workflow_cron_now"
    triggers:
      - type: cron
        schedule: "0 * * * *"
        params:
          timestamp: "now"
    steps:
      - name: run
        type: query
        database: "primary"
        sql: "SELECT @timestamp AS timestamp"

  # Cron with tomorrow param
  - name: "workflow_cron_tomorrow"
    triggers:
      - type: cron
        schedule: "0 6 * * *"
        params:
          date: "tomorrow"
    steps:
      - name: run
        type: query
        database: "primary"
        sql: "SELECT @date AS date_value"

  # ============================================
  # Cron with httpcall (webhook equivalent)
  # ============================================

  # Cron workflow with basic httpcall (replaces scheduled query webhook)
  - name: "workflow_cron_webhook"
    triggers:
      - type: cron
        schedule: "*/15 * * * *"
    steps:
      - name: fetch
        type: query
        database: "primary"
        sql: "SELECT 'data' AS result, 42 AS count"
      - name: notify
        type: httpcall
        url: "https://example.com/webhook"
        http_method: POST
        headers:
          Content-Type: "application/json"
          X-Custom-Header: "test"
        body: |
          {"query_result": {{json .steps.fetch.data}}}
        parse: "json"

  # Cron workflow with httpcall retry (replaces scheduled query webhook retry)
  - name: "workflow_cron_webhook_retry"
    triggers:
      - type: cron
        schedule: "30 * * * *"
    steps:
      - name: fetch
        type: query
        database: "primary"
        sql: "SELECT 'important' AS data"
      - name: notify
        type: httpcall
        url: "https://example.com/critical"
        http_method: PUT
        body: |
          {{json .steps.fetch.data}}
        retry:
          enabled: true
          max_attempts: 5
          initial_backoff_sec: 2
          max_backoff_sec: 60

  # Cron workflow with conditional httpcall (skip on empty)
  - name: "workflow_cron_conditional_webhook"
    conditions:
      has_data: "steps.fetch.count > 0"
    triggers:
      - type: cron
        schedule: "0 12 * * *"
    steps:
      - name: fetch
        type: query
        database: "primary"
        sql: "SELECT * FROM (SELECT 1) WHERE 0"
      - name: notify
        type: httpcall
        condition: "has_data"
        url: "https://example.com/notify"
        http_method: POST
        body: |
          {"items": {{json .steps.fetch.data}}}

  # ============================================
  # Various Cron Expression Formats (validation)
  # ============================================

  - name: "workflow_cron_every_minute"
    triggers:
      - type: cron
        schedule: "* * * * *"
    steps:
      - name: run
        type: query
        database: "primary"
        sql: "SELECT 1"

  - name: "workflow_cron_hourly"
    triggers:
      - type: cron
        schedule: "0 * * * *"
    steps:
      - name: run
        type: query
        database: "primary"
        sql: "SELECT 1"

  - name: "workflow_cron_daily"
    triggers:
      - type: cron
        schedule: "0 0 * * *"
    steps:
      - name: run
        type: query
        database: "primary"
        sql: "SELECT 1"

  - name: "workflow_cron_weekly"
    triggers:
      - type: cron
        schedule: "0 0 * * 1"
    steps:
      - name: run
        type: query
        database: "primary"
        sql: "SELECT 1"

  - name: "workflow_cron_monthly"
    triggers:
      - type: cron
        schedule: "0 0 1 * *"
    steps:
      - name: run
        type: query
        database: "primary"
        sql: "SELECT 1"

  - name: "workflow_cron_specific"
    triggers:
      - type: cron
        schedule: "30 9 * * 1-5"
    steps:
      - name: run
        type: query
        database: "primary"
        sql: "SELECT 1"

  - name: "workflow_cron_range"
    triggers:
      - type: cron
        schedule: "*/5 9-17 * * *"
    steps:
      - name: run
        type: query
        database: "primary"
        sql: "SELECT 1"

  # ============================================
  # Template Functions
  # ============================================

  # Workflow exercising all template functions
  - name: "workflow_template_funcs"
    triggers:
      - type: http
        path: "/api/v2/template-funcs"
        method: GET
        parameters:
          - name: "name"
            type: "string"
            required: false
            default: "  hello world  "
          - name: "status"
            type: "string"
            required: false
            default: ""
          - name: "count"
            type: "int"
            required: false
            default: "10"
    steps:
      - name: fetch
        type: query
        database: "primary"
        sql: |
          SELECT
            'item1' AS name,
            100 AS price
          UNION ALL SELECT 'item2', 200
      - type: response
        template: |
          {
            "string_funcs": {
              "upper": "{{upper .trigger.params.name}}",
              "lower": "{{lower .trigger.params.name}}",
              "trim": "{{trim .trigger.params.name}}"
            },
            "default_funcs": {
              "with_default": "{{.trigger.params.status | default \"active\"}}",
              "coalesce": "{{coalesce .trigger.params.status \"fallback\"}}"
            },
            "math_funcs": {
              "add": {{add .trigger.params.count 5}},
              "sub": {{sub .trigger.params.count 3}},
              "mul": {{mul .trigger.params.count 2}},
              "div": {{div .trigger.params.count 2}},
              "mod": {{mod .trigger.params.count 3}}
            },
            "json_funcs": {
              "data": {{json .steps.fetch.data}},
              "count": {{.steps.fetch.count}}
            }
          }

  # ============================================
  # Other Features
  # ============================================

  # Query using minimal database
  - name: "workflow_minimal_db"
    triggers:
      - type: http
        path: "/api/v2/minimal"
        method: GET
    steps:
      - name: fetch
        type: query
        database: "minimal"
        sql: "SELECT 'minimal' AS db"
      - type: response
        template: |
          {"db": "{{index .steps.fetch.data 0 \"db\"}}"}

  # Complex workflow with multiple combined features
  - name: "workflow_complex"
    timeout_sec: 45
    conditions:
      has_results: "steps.search.count > 0"
    triggers:
      - type: http
        path: "/api/v2/complex"
        method: GET
        parameters:
          - name: "search"
            type: "string"
            required: false
            default: ""
          - name: "page"
            type: "int"
            required: false
            default: "1"
          - name: "limit"
            type: "int"
            required: false
            default: "20"
          - name: "active"
            type: "bool"
            required: false
            default: "true"
        cache:
          enabled: true
          key: "wf:search:{{.search | default \"all\"}}:{{.page}}:{{.limit}}:{{.active}}"
          ttl_sec: 60
        rate_limit:
          - pool: "default"
          - requests_per_second: 30
            burst: 60
            key: "{{.ClientIP}}:search"
    steps:
      - name: search
        type: query
        database: "primary"
        sql: |
          SELECT
            @search AS search_term,
            @page AS page_num,
            @limit AS page_size,
            @active AS is_active,
            datetime('now') AS queried_at
      - type: response
        template: |
          {"search": "{{index .steps.search.data 0 \"search_term\"}}", "page": {{index .steps.search.data 0 "page_num"}}, "cached_at": "{{index .steps.search.data 0 \"queried_at\"}}"}
