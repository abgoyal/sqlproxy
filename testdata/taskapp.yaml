# Comprehensive Task Management API
# Exercises ALL sql-proxy features for exhaustive E2E testing
#
# Features covered:
# - Path parameters (/api/tasks/{id})
# - All HTTP methods (GET, POST, PUT, DELETE, PATCH, HEAD, OPTIONS)
# - Trigger-level caching (X-Cache headers)
# - Step-level caching
# - Rate limiting (429 responses)
# - Conditional responses (404 for missing)
# - Template functions (string, math, default)
# - Array/JSON parameters
# - Blocks with iteration
# - on_error: continue
# - Disabled steps

server:
  host: "127.0.0.1"
  port: ${PORT}
  default_timeout_sec: 30
  max_timeout_sec: 300
  cache:
    enabled: true
    max_size_mb: 256
    default_ttl_sec: 300

databases:
  - name: "main"
    type: "sqlite"
    path: "${DB_PATH}"
    readonly: false

rate_limits:
  - name: "create_limit"
    requests_per_second: 2
    burst: 3
    key: "{{.ClientIP}}"

logging:
  level: "debug"
  file_path: "/tmp/sql-proxy-taskapp.log"
  max_size_mb: 10
  max_backups: 1
  max_age_days: 1

metrics:
  enabled: true

workflows:
  # ============================================================================
  # DATABASE INITIALIZATION
  # ============================================================================

  - name: "init_db"
    triggers:
      - type: http
        path: "/api/init"
        method: POST
    steps:
      - name: create_tasks
        type: query
        database: "main"
        sql: |
          CREATE TABLE IF NOT EXISTS tasks (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            title TEXT NOT NULL,
            description TEXT DEFAULT '',
            status TEXT DEFAULT 'pending',
            priority INTEGER DEFAULT 0,
            due_date TEXT,
            created_at TEXT DEFAULT (datetime('now'))
          )
      - name: create_categories
        type: query
        database: "main"
        sql: |
          CREATE TABLE IF NOT EXISTS categories (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT NOT NULL UNIQUE
          )
      - name: seed_categories
        type: query
        database: "main"
        sql: |
          INSERT OR IGNORE INTO categories (id, name) VALUES
            (1, 'Work'),
            (2, 'Personal'),
            (3, 'Shopping')
      - name: seed_tasks
        type: query
        database: "main"
        sql: |
          INSERT OR IGNORE INTO tasks (id, title, description, status, priority) VALUES
            (1, 'Review PR', 'Review the pull request for feature X', 'pending', 2),
            (2, 'Write tests', 'Add unit tests for new module', 'in_progress', 1),
            (3, 'Deploy', 'Deploy to production', 'completed', 3)
      - type: response
        status_code: 201
        template: '{"success": true, "message": "Database initialized"}'

  # ============================================================================
  # COLLECTION ENDPOINTS - /api/tasks
  # ============================================================================

  # GET /api/tasks - List tasks with pagination and filtering
  - name: "list_tasks"
    triggers:
      - type: http
        path: "/api/tasks"
        method: GET
        parameters:
          - name: "status"
            type: "string"
            required: false
            default: ""
          - name: "priority"
            type: "int"
            required: false
            default: "0"
          - name: "limit"
            type: "int"
            required: false
            default: "10"
          - name: "page"
            type: "int"
            required: false
            default: "1"
    steps:
      - name: fetch
        type: query
        database: "main"
        sql: |
          SELECT id, title, description, status, priority, due_date, created_at
          FROM tasks
          WHERE (@status = '' OR status = @status)
            AND (@priority = 0 OR priority = @priority)
          ORDER BY priority DESC, created_at DESC
          LIMIT @limit OFFSET ((@page - 1) * @limit)
      - name: count
        type: query
        database: "main"
        sql: |
          SELECT COUNT(*) as total FROM tasks
          WHERE (@status = '' OR status = @status)
            AND (@priority = 0 OR priority = @priority)
      - type: response
        template: |
          {
            "tasks": {{json .steps.fetch.data}},
            "count": {{.steps.fetch.count}},
            "total": {{index .steps.count.data 0 "total"}},
            "page": {{.trigger.params.page}},
            "limit": {{.trigger.params.limit}}
          }

  # POST /api/tasks - Create task (with rate limiting)
  - name: "create_task"
    triggers:
      - type: http
        path: "/api/tasks"
        method: POST
        parameters:
          - name: "title"
            type: "string"
            required: true
          - name: "description"
            type: "string"
            required: false
            default: ""
          - name: "status"
            type: "string"
            required: false
            default: "pending"
          - name: "priority"
            type: "int"
            required: false
            default: "0"
          - name: "due_date"
            type: "string"
            required: false
            default: ""
        rate_limit:
          - pool: "create_limit"
    steps:
      - name: insert
        type: query
        database: "main"
        sql: |
          INSERT INTO tasks (title, description, status, priority, due_date)
          VALUES (@title, @description, @status, @priority, NULLIF(@due_date, ''))
      - name: get_id
        type: query
        database: "main"
        sql: "SELECT last_insert_rowid() AS id"
      - type: response
        status_code: 201
        template: |
          {
            "success": true,
            "id": {{index .steps.get_id.data 0 "id"}},
            "title": "{{.trigger.params.title}}"
          }

  # HEAD /api/tasks - Check if tasks exist
  - name: "tasks_head"
    triggers:
      - type: http
        path: "/api/tasks"
        method: HEAD
        parameters:
          - name: "status"
            type: "string"
            required: false
            default: ""
    steps:
      - name: count
        type: query
        database: "main"
        sql: |
          SELECT COUNT(*) AS cnt FROM tasks
          WHERE (@status = '' OR status = @status)
      - type: response
        headers:
          X-Total-Count: "{{index .steps.count.data 0 \"cnt\"}}"
        template: "{}"

  # OPTIONS /api/tasks - List available methods
  - name: "tasks_options"
    triggers:
      - type: http
        path: "/api/tasks"
        method: OPTIONS
    steps:
      - type: response
        headers:
          Allow: "GET, POST, HEAD, OPTIONS"
          Access-Control-Allow-Methods: "GET, POST, HEAD, OPTIONS"
        template: '{"methods": ["GET", "POST", "HEAD", "OPTIONS"]}'

  # ============================================================================
  # SINGLE RESOURCE ENDPOINTS - /api/tasks/{id}
  # ============================================================================

  # GET /api/tasks/{id} - Get single task with caching
  - name: "get_task"
    triggers:
      - type: http
        path: "/api/tasks/{id}"
        method: GET
        parameters:
          - name: "id"
            type: "int"
            required: true
        cache:
          enabled: true
          key: "task:{{.Param.id}}"
          ttl_sec: 60
    conditions:
      found: "steps.fetch.count > 0"
    steps:
      - name: fetch
        type: query
        database: "main"
        sql: "SELECT * FROM tasks WHERE id = @id"
      - type: response
        condition: "found"
        template: |
          {
            "task": {{json (index .steps.fetch.data 0)}},
            "cache_hit": {{.steps.fetch.cache_hit}}
          }
      - type: response
        condition: "!found"
        status_code: 404
        template: '{"error": "Task not found", "id": {{.trigger.params.id}}}'

  # PUT /api/tasks/{id} - Replace task
  - name: "replace_task"
    triggers:
      - type: http
        path: "/api/tasks/{id}"
        method: PUT
        parameters:
          - name: "id"
            type: "int"
            required: true
          - name: "title"
            type: "string"
            required: true
          - name: "description"
            type: "string"
            required: true
          - name: "status"
            type: "string"
            required: true
          - name: "priority"
            type: "int"
            required: true
    conditions:
      exists: "steps.check.count > 0"
    steps:
      - name: check
        type: query
        database: "main"
        sql: "SELECT 1 FROM tasks WHERE id = @id"
      - name: update
        type: query
        database: "main"
        condition: "exists"
        sql: |
          UPDATE tasks
          SET title = @title, description = @description,
              status = @status, priority = @priority
          WHERE id = @id
      - type: response
        condition: "exists"
        template: |
          {
            "success": true,
            "id": {{.trigger.params.id}},
            "title": "{{.trigger.params.title | upper}}"
          }
      - type: response
        condition: "!exists"
        status_code: 404
        template: '{"error": "Task not found", "id": {{.trigger.params.id}}}'

  # PATCH /api/tasks/{id} - Partial update
  - name: "update_task"
    triggers:
      - type: http
        path: "/api/tasks/{id}"
        method: PATCH
        parameters:
          - name: "id"
            type: "int"
            required: true
          - name: "title"
            type: "string"
            required: false
          - name: "description"
            type: "string"
            required: false
          - name: "status"
            type: "string"
            required: false
          - name: "priority"
            type: "int"
            required: false
            default: "-1"
    conditions:
      exists: "steps.check.count > 0"
    steps:
      - name: check
        type: query
        database: "main"
        sql: "SELECT 1 FROM tasks WHERE id = @id"
      - name: update
        type: query
        database: "main"
        condition: "exists"
        sql: |
          UPDATE tasks
          SET title = COALESCE(NULLIF(@title, ''), title),
              description = COALESCE(NULLIF(@description, ''), description),
              status = COALESCE(NULLIF(@status, ''), status),
              priority = CASE WHEN @priority >= 0 THEN @priority ELSE priority END
          WHERE id = @id
      - type: response
        condition: "exists"
        template: '{"success": true, "id": {{.trigger.params.id}}}'
      - type: response
        condition: "!exists"
        status_code: 404
        template: '{"error": "Task not found", "id": {{.trigger.params.id}}}'

  # DELETE /api/tasks/{id} - Delete task
  - name: "delete_task"
    triggers:
      - type: http
        path: "/api/tasks/{id}"
        method: DELETE
        parameters:
          - name: "id"
            type: "int"
            required: true
    conditions:
      exists: "steps.check.count > 0"
    steps:
      - name: check
        type: query
        database: "main"
        sql: "SELECT 1 FROM tasks WHERE id = @id"
      - name: delete
        type: query
        database: "main"
        condition: "exists"
        sql: "DELETE FROM tasks WHERE id = @id"
      - type: response
        condition: "exists"
        template: '{"success": true, "deleted_id": {{.trigger.params.id}}}'
      - type: response
        condition: "!exists"
        status_code: 404
        template: '{"error": "Task not found", "id": {{.trigger.params.id}}}'

  # HEAD /api/tasks/{id} - Check if task exists
  - name: "task_exists"
    triggers:
      - type: http
        path: "/api/tasks/{id}"
        method: HEAD
        parameters:
          - name: "id"
            type: "int"
            required: true
    conditions:
      found: "steps.check.count > 0"
    steps:
      - name: check
        type: query
        database: "main"
        sql: "SELECT 1 FROM tasks WHERE id = @id"
      - type: response
        condition: "found"
        headers:
          X-Exists: "true"
        template: "{}"
      - type: response
        condition: "!found"
        status_code: 404
        headers:
          X-Exists: "false"
        template: "{}"

  # OPTIONS /api/tasks/{id} - List available methods
  - name: "task_options"
    triggers:
      - type: http
        path: "/api/tasks/{id}"
        method: OPTIONS
        parameters:
          - name: "id"
            type: "int"
            required: true
    steps:
      - type: response
        headers:
          Allow: "GET, PUT, PATCH, DELETE, HEAD, OPTIONS"
          Access-Control-Allow-Methods: "GET, PUT, PATCH, DELETE, HEAD, OPTIONS"
        template: '{"methods": ["GET", "PUT", "PATCH", "DELETE", "HEAD", "OPTIONS"]}'

  # ============================================================================
  # BATCH OPERATIONS - Blocks with Iteration
  # ============================================================================

  # POST /api/tasks/batch - Batch create tasks
  - name: "batch_create"
    triggers:
      - type: http
        path: "/api/tasks/batch"
        method: POST
        parameters:
          - name: "tasks"
            type: "json"
            required: true
    steps:
      - name: batch
        iterate:
          over: "trigger.params.tasks"
          as: "task"
          on_error: continue
        steps:
          - name: insert
            type: query
            database: "main"
            sql: |
              INSERT INTO tasks (title, description, status, priority)
              VALUES (@title, COALESCE(@description, ''), COALESCE(@status, 'pending'), COALESCE(@priority, 0))
      - type: response
        status_code: 201
        template: |
          {
            "success": true,
            "created": {{.steps.batch.success_count}},
            "failed": {{.steps.batch.failure_count}}
          }

  # DELETE /api/tasks/batch - Batch delete tasks by IDs
  - name: "batch_delete"
    triggers:
      - type: http
        path: "/api/tasks/batch"
        method: DELETE
        parameters:
          - name: "ids"
            type: "json"
            required: true
    steps:
      - name: batch
        iterate:
          over: "trigger.params.ids"
          as: "task_id"
          on_error: continue
        steps:
          - name: del
            type: query
            database: "main"
            sql: "DELETE FROM tasks WHERE id = @task_id"
      - type: response
        template: |
          {
            "success": true,
            "deleted": {{.steps.batch.success_count}},
            "failed": {{.steps.batch.failure_count}}
          }

  # ============================================================================
  # STEP CACHING - Cached intermediate step
  # ============================================================================

  # GET /api/stats - Get task statistics with step caching
  - name: "task_stats"
    triggers:
      - type: http
        path: "/api/stats"
        method: GET
    steps:
      - name: counts
        type: query
        database: "main"
        cache:
          key: "stats:counts"
          ttl_sec: 30
        sql: |
          SELECT
            COUNT(*) as total,
            SUM(CASE WHEN status = 'pending' THEN 1 ELSE 0 END) as pending,
            SUM(CASE WHEN status = 'in_progress' THEN 1 ELSE 0 END) as in_progress,
            SUM(CASE WHEN status = 'completed' THEN 1 ELSE 0 END) as completed
          FROM tasks
      - name: priority_avg
        type: query
        database: "main"
        sql: "SELECT AVG(priority) as avg_priority FROM tasks"
      - type: response
        template: |
          {
            "stats": {{json (index .steps.counts.data 0)}},
            "avg_priority": {{index .steps.priority_avg.data 0 "avg_priority" | default 0}},
            "counts_cached": {{.steps.counts.cache_hit}}
          }

  # ============================================================================
  # TEMPLATE FUNCTIONS - String and math operations
  # ============================================================================

  # GET /api/search/tasks - Search with template functions
  - name: "search_tasks"
    triggers:
      - type: http
        path: "/api/search/tasks"
        method: GET
        parameters:
          - name: "q"
            type: "string"
            required: true
          - name: "case_sensitive"
            type: "bool"
            required: false
            default: "false"
    steps:
      - name: search
        type: query
        database: "main"
        sql: |
          SELECT id, title, description, status, priority
          FROM tasks
          WHERE
            CASE WHEN @case_sensitive THEN
              title LIKE '%' || @q || '%' OR description LIKE '%' || @q || '%'
            ELSE
              LOWER(title) LIKE '%' || LOWER(@q) || '%' OR
              LOWER(description) LIKE '%' || LOWER(@q) || '%'
            END
          ORDER BY priority DESC
      - type: response
        template: |
          {
            "query": "{{.trigger.params.q | lower | trim}}",
            "results": {{json .steps.search.data}},
            "count": {{.steps.search.count}}
          }

  # ============================================================================
  # DISABLED STEP - Audit logging (disabled)
  # ============================================================================

  # POST /api/tasks/{id}/complete - Complete task with disabled audit step
  - name: "complete_task"
    triggers:
      - type: http
        path: "/api/tasks/{id}/complete"
        method: POST
        parameters:
          - name: "id"
            type: "int"
            required: true
    conditions:
      exists: "steps.check.count > 0"
    steps:
      - name: check
        type: query
        database: "main"
        sql: "SELECT status FROM tasks WHERE id = @id"
      - name: update
        type: query
        database: "main"
        condition: "exists"
        sql: "UPDATE tasks SET status = 'completed' WHERE id = @id"
      - name: audit
        type: query
        database: "main"
        condition: "exists"
        disabled: true
        sql: |
          INSERT INTO audit_log (task_id, action, timestamp)
          VALUES (@id, 'completed', datetime('now'))
      - type: response
        condition: "exists"
        template: |
          {
            "success": true,
            "id": {{.trigger.params.id}},
            "previous_status": "{{index .steps.check.data 0 "status"}}",
            "new_status": "completed"
          }
      - type: response
        condition: "!exists"
        status_code: 404
        template: '{"error": "Task not found", "id": {{.trigger.params.id}}}'

  # ============================================================================
  # CATEGORIES - Additional entity for testing
  # ============================================================================

  # GET /api/categories - List categories
  - name: "list_categories"
    triggers:
      - type: http
        path: "/api/categories"
        method: GET
    steps:
      - name: fetch
        type: query
        database: "main"
        sql: "SELECT id, name FROM categories ORDER BY name"
      - type: response
        template: '{"categories": {{json .steps.fetch.data}}, "count": {{.steps.fetch.count}}}'

  # GET /api/categories/{id} - Get single category
  - name: "get_category"
    triggers:
      - type: http
        path: "/api/categories/{id}"
        method: GET
        parameters:
          - name: "id"
            type: "int"
            required: true
    conditions:
      found: "steps.fetch.count > 0"
    steps:
      - name: fetch
        type: query
        database: "main"
        sql: "SELECT * FROM categories WHERE id = @id"
      - type: response
        condition: "found"
        template: '{"category": {{json (index .steps.fetch.data 0)}}}'
      - type: response
        condition: "!found"
        status_code: 404
        template: '{"error": "Category not found", "id": {{.trigger.params.id}}}'
